import { AbletonLive } from './index';
interface ChildrenInitialProps {
    name: string;
    initialProps: string[];
}
export declare class Properties<GP, CP, TP, SP, OP> {
    protected ableton: AbletonLive;
    protected ns: string;
    protected _path: string;
    protected childrenInitialProps?: Partial<{ [T in keyof CP]: (string | ChildrenInitialProps)[]; }> | undefined;
    protected _id?: number | undefined;
    protected _state: Map<any, any>;
    constructor(ableton: AbletonLive, ns: string, _path: string, childrenInitialProps?: Partial<{ [T in keyof CP]: (string | ChildrenInitialProps)[]; }> | undefined, _id?: number | undefined);
    get id(): number | undefined;
    get path(): string;
    /**
     * @private
     * Under construction
     */
    protected getterTransformers: Partial<{
        [T in keyof GP]: (val: GP[T]) => any;
    }>;
    protected childrenTransformers: Partial<{
        [T in keyof CP]: (val: CP[T]) => any;
    }>;
    get<T extends keyof GP>(prop: T): Promise<T extends keyof TP ? TP[T] : GP[T]>;
    children<TName extends keyof CP>(child: TName, childProps?: string[], index?: number): Promise<PropertyType<TName, TP, CP>>;
    child<TName extends OnlyKeysWithArrayValues<CP, TP>>(child: TName, index: number, childProps?: string[]): Promise<FlatPropertyType<TName, TP, CP>>;
    set<T extends keyof SP>(prop: T, value: SP[T]): Promise<null>;
    observe<T extends keyof OP | keyof CP>(prop: T, listener: (data: T extends keyof OP ? OP[T] : T extends keyof TP ? TP[T] : any) => any): Promise<any>;
    protected call(method: string, parameters?: any[], timeout?: number): Promise<any>;
    protected callMultiple(calls: any[][], timeout?: number): Promise<any>;
}
type PropertyType<TName extends keyof CP, TP, CP> = TName extends keyof TP ? TP[TName] : CP[TName];
type FlatPropertyType<TName extends keyof CP, TP, CP> = TName extends keyof TP ? Flatten<TP[TName]> : Flatten<CP[TName]>;
type Flatten<T> = T extends Array<infer U> ? Flatten<U> : T;
type OnlyKeysWithArrayValues<T, TLookUp> = {
    [K in keyof T]: K extends keyof TLookUp ? TLookUp[K] extends Array<any> ? K : never : T[K] extends Array<any> ? K : never;
}[keyof T];
export {};
